--// SERVICES
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

--// ANIMATION CONFIG
local TARGET_ANIM_ID = "rbxassetid://95421145178968"      -- Original (signal only)
local REPLACEMENT_ANIM_ID = "rbxassetid://76313364850487" -- Replacement

local DEFAULT_DURATION = 4
local LOW_HP_START = 5.3
local LOW_HP_DURATION = 20
local COOLDOWN_TIME = 4

--// STATE
local onCooldown = false
local currentReplacementTrack = nil
local animConnection = nil

--// REPLACEMENT ANIMATION OBJECT (reused safely)
local replacementAnimation = Instance.new("Animation")
replacementAnimation.AnimationId = REPLACEMENT_ANIM_ID

--// Find nearest player
local function getNearestPlayer(character)
	local nearestPlayer = nil
	local shortestDistance = math.huge
	local root = character:FindFirstChild("HumanoidRootPart")
	if not root then return nil end

	for _, player in ipairs(Players:GetPlayers()) do
		if player ~= LocalPlayer and player.Character then
			local otherRoot = player.Character:FindFirstChild("HumanoidRootPart")
			local otherHumanoid = player.Character:FindFirstChild("Humanoid")
			if otherRoot and otherHumanoid then
				local dist = (otherRoot.Position - root.Position).Magnitude
				if dist < shortestDistance then
					shortestDistance = dist
					nearestPlayer = player
				end
			end
		end
	end

	return nearestPlayer
end

--// Play replacement animation
local function playReplacement(humanoid, originalTrack, character)
	if onCooldown then return end
	onCooldown = true

	local animStart = 0
	local animDuration = DEFAULT_DURATION

	local nearest = getNearestPlayer(character)
	if nearest and nearest.Character then
		local nh = nearest.Character:FindFirstChild("Humanoid")
		if nh and nh.Health > 0 and nh.Health / nh.MaxHealth <= 0.1 then
			animStart = LOW_HP_START
			animDuration = LOW_HP_DURATION
		end
	end

	currentReplacementTrack = humanoid:LoadAnimation(replacementAnimation)
	currentReplacementTrack.Looped = false
	currentReplacementTrack:Play()
	currentReplacementTrack.TimePosition = animStart

	-- Stop replacement when original stops
	local stopConn
	stopConn = originalTrack.Stopped:Connect(function()
		if currentReplacementTrack and currentReplacementTrack.IsPlaying then
			currentReplacementTrack:Stop()
		end
		stopConn:Disconnect()
	end)

	-- Stop after segment duration
	task.delay(animDuration, function()
		if currentReplacementTrack and currentReplacementTrack.IsPlaying then
			currentReplacementTrack:Stop()
		end
	end)

	-- Cooldown
	task.delay(animDuration + COOLDOWN_TIME, function()
		onCooldown = false
	end)
end

--// SETUP FOR EACH RESPAWN
local function onCharacterAdded(character)
	local humanoid = character:WaitForChild("Humanoid")

	-- Disconnect old connection if it exists
	if animConnection then
		animConnection:Disconnect()
	end

	animConnection = humanoid.AnimationPlayed:Connect(function(track)
		if track.Animation and track.Animation.AnimationId == TARGET_ANIM_ID then
			if track.IsPlaying then
				track:Stop()
			end
			playReplacement(humanoid, track, character)
		end
	end)
end

--// INITIAL + RESPAWNS
if LocalPlayer.Character then
	onCharacterAdded(LocalPlayer.Character)
end

LocalPlayer.CharacterAdded:Connect(onCharacterAdded)



-- Dash animation 

-- Services
local Players = game:GetService("Players")
local player = Players.LocalPlayer

-- Animation IDs
local originalAnimId = "rbxassetid://110978068388232"
local replacementAnimId = "rbxassetid://86430725083594"
local replacementStart = 0.3
local replacementDuration = 1.1

-- Function to handle humanoid animations
local function setupHumanoid(humanoid)
    -- Cache replacement animation for this humanoid
    local replacementAnim = Instance.new("Animation")
    replacementAnim.AnimationId = replacementAnimId
    local replacementTrack = humanoid:LoadAnimation(replacementAnim)

    local function onTrackPlayed(track)
        if track.Animation.AnimationId == originalAnimId then
            -- Stop and disable the original
            track:Stop()
            track:Destroy()

            -- Play replacement animation segment
            replacementTrack.TimePosition = replacementStart
            replacementTrack:Play()

            -- Stop after the replacement duration
            task.spawn(function()
                local startTime = tick()
                while tick() - startTime < replacementDuration and replacementTrack.IsPlaying do
                    task.wait()
                end
                if replacementTrack.IsPlaying then
                    replacementTrack:Stop()
                end
            end)
        end
    end

    humanoid.AnimationPlayed:Connect(onTrackPlayed)
end

-- Function to handle character spawn
local function onCharacterAdded(character)
    local humanoid = character:WaitForChild("Humanoid")
    setupHumanoid(humanoid)
end

-- Connect for current character
if player.Character then
    onCharacterAdded(player.Character)
end

-- Connect for future respawns
player.CharacterAdded:Connect(onCharacterAdded)

-- blue animation

--// SERVICES
local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer

--// ANIMATION DATA
local ANIM_A_ID = "rbxassetid://137865634124104"
local ANIM_A_DURATION = 0.8

local ANIM_B_ID = "rbxassetid://104749346956269"
local ANIM_B_START = 2.3
local ANIM_B_DURATION = 1

--// LEVITATION DATA
local LEVITATE_HEIGHT = 10 -- studs
local LEVITATE_DURATION = 1 -- seconds to rise

--// STATE
local sequenceRunning = false
local cooldown = false
local COOLDOWN_TIME = 4 -- seconds

--// PRELOAD ANIMATIONS (reuse objects to reduce lag)
local animations = {}
animations.A = Instance.new("Animation")
animations.A.AnimationId = ANIM_A_ID

animations.B = Instance.new("Animation")
animations.B.AnimationId = ANIM_B_ID

--// FUNCTION TO PLAY ANIMATION
local function playAnimation(humanoid, animObject, fadeTime, weight)
	local animator = humanoid:FindFirstChildWhichIsA("Animator")
	if not animator then
		animator = Instance.new("Animator")
		animator.Parent = humanoid
	end

	local track = animator:LoadAnimation(animObject)
	track:Play(fadeTime or 0.1, weight or 1, 1)
	return track
end

--// STOP ALL ANIMATION A TRACKS
local function stopAllATracks(humanoid)
	local animator = humanoid:FindFirstChildWhichIsA("Animator")
	if animator then
		for _, track in ipairs(animator:GetPlayingAnimationTracks()) do
			if track.Animation and track.Animation.AnimationId == ANIM_A_ID then
				track:Stop()
			end
		end
	end
end

--// SMOOTH LEVITATION USING TWEEN
local function levitatePlayerTween(character, height, duration, callback)
	local hrp = character:FindFirstChild("HumanoidRootPart")
	if not hrp then return end

	-- Remove existing BodyPosition
	if hrp:FindFirstChild("LevitateBP") then
		hrp.LevitateBP:Destroy()
	end

	local startPos = hrp.Position
	local targetPos = startPos + Vector3.new(0, height, 0)

	local bp = Instance.new("BodyPosition")
	bp.Name = "LevitateBP"
	bp.MaxForce = Vector3.new(1e5,1e5,1e5)
	bp.Position = startPos
	bp.P = 1e4
	bp.D = 500
	bp.Parent = hrp

	local tweenInfo = TweenInfo.new(duration, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
	local tween = TweenService:Create(bp, tweenInfo, {Position = targetPos})
	tween:Play()

	tween.Completed:Connect(function()
		bp:Destroy() -- Let gravity handle falling
		if callback then callback() end
	end)
end

--// RUN CONTROLLED SEQUENCE
local function runSequence(humanoid, trackA)
	if sequenceRunning or cooldown then return end
	sequenceRunning = true
	cooldown = true

	-- Let A play for its duration
	task.delay(ANIM_A_DURATION, function()
		if trackA and trackA.IsPlaying then
			trackA:Stop()
		end

		stopAllATracks(humanoid)

		local character = humanoid.Parent
		if not character then
			sequenceRunning = false
			return
		end

		-- Play Animation B starting at 2.3s
		local trackB = playAnimation(humanoid, animations.B)
		trackB.TimePosition = ANIM_B_START

		-- Smooth rise at start of B using Tween
		levitatePlayerTween(character, LEVITATE_HEIGHT, LEVITATE_DURATION, function()
			-- Stop B after duration
			task.delay(ANIM_B_DURATION, function()
				if trackB and trackB.IsPlaying then
					trackB:Stop()
				end
				sequenceRunning = false
			end)
		end)
	end)

	-- Start cooldown timer
	task.delay(COOLDOWN_TIME, function()
		cooldown = false
	end)
end

--// DETECT ORIGINAL ANIMATION A
local function detectAnimationA(character)
	local humanoid = character:WaitForChild("Humanoid")
	local animator = humanoid:WaitForChild("Animator")

	animator.AnimationPlayed:Connect(function(track)
		if not track.Animation then return end
		if track.Animation.AnimationId == ANIM_A_ID then
			if not sequenceRunning and not cooldown then
				runSequence(humanoid, track)
			end
		end
	end)
end

--// CHARACTER HANDLING
player.CharacterAdded:Connect(detectAnimationA)
if player.Character then
	detectAnimationA(player.Character)
end
